        - # Tests for Compiled Test Fixtures
        - 
        - # Check if CUDA is available (both hardware and CUDA.jl)
        - const CUDA_AVAILABLE = begin
        -     cuda_functional = try
        -         using CUDA
        -         functional = CUDA.functional()
        -         if functional
        -             ensure_fixture_built("add_one_cuda")
        -         end
        -         functional
        -     catch e
        -         false
        -     end
        - end
        - 
        - # Check if Metal is available (both hardware and Metal.jl)
        - const METAL_AVAILABLE = begin
        -     metal_functional = try
        -         using Metal
        -         functional = Metal.functional()
        -         if functional
        -             ensure_fixture_built("add_one_metal")
        -         end
        -         functional
        -     catch e
        -         false
        -     end
        - end
        - 
        1 @testset "Test Fixtures" begin
        1     @testset "add_one_cpu - Basic" begin
        -         # Load fixture (auto-builds if needed)
        2         mod = load_fixture("add_one_cpu")
        1         @test mod isa TVMModule
        2         @test implements_function(mod, "add_one_cpu")
        - 
        1         add_one = mod["add_one_cpu"]
        1         @test add_one isa TVMFunction
        - 
        -         # Test: [1, 2, 3, 4, 5] + 1 = [2, 3, 4, 5, 6]
        1         x = Float32[1, 2, 3, 4, 5]
        1         y = similar(x)
        1         add_one(TensorView(x), TensorView(y))
        1         @test y ≈ Float32[2, 3, 4, 5, 6]
        - 
        -         # Test: [10, 20, 30] + 1 = [11, 21, 31]
        1         x2 = Float32[10, 20, 30]
        1         y2 = similar(x2)
        1         add_one(TensorView(x2), TensorView(y2))
        1         @test y2 ≈ Float32[11, 21, 31]
        - 
        -         # Test: zeros + 1 = ones
        1         x3 = zeros(Float32, 10)
        1         y3 = similar(x3)
        1         add_one(TensorView(x3), TensorView(y3))
        1         @test y3 ≈ ones(Float32, 10)
        -     end
        - 
        -     @testset "add_one_cpu - Strided Arrays" begin
        2         mod = load_fixture("add_one_cpu")
        1         add_one = mod["add_one_cpu"]
        - 
        -         # Test 1: 1D contiguous slice
        1         vec = Float32[10, 20, 30, 40, 50, 60]
        1         x_slice = @view vec[2:5]
        1         y_slice = similar(x_slice)
        1         add_one(TensorView(x_slice), TensorView(y_slice))
        1         @test y_slice ≈ Float32[21, 31, 41, 51]
        - 
        -         # Test 2: 1D strided view (every 2nd element)
        1         x_vec = Float32[1, 2, 3, 4, 5, 6, 7, 8]
        1         y_vec = zeros(Float32, 8)
        1         x_strided = @view x_vec[1:2:end]  # [1, 3, 5, 7]
        1         y_strided = @view y_vec[1:2:end]  # Output with stride=2
        1         add_one(TensorView(x_strided), TensorView(y_strided))
        1         @test y_strided ≈ Float32[2, 4, 6, 8]
        - 
        -         # Test 3: 2D contiguous array
        1         x_mat = Float32[1 2 3; 4 5 6]  # 2×3
        1         y_mat = similar(x_mat)
        1         add_one(TensorView(x_mat), TensorView(y_mat))
        1         @test y_mat ≈ Float32[2 3 4; 5 6 7]
        - 
        -         # Test 4: 2D column slice (contiguous in column-major)
        1         mat = Float32[1 2 3 4; 5 6 7 8; 9 10 11 12]  # 3×4
        1         x_col = @view mat[:, 2]  # [2, 6, 10]
        1         y_col = similar(x_col)
        1         add_one(TensorView(x_col), TensorView(y_col))
        1         @test y_col ≈ Float32[3, 7, 11]
        - 
        -         # Test 5: 2D row slice (NON-contiguous, stride > 1)
        1         x_row = @view mat[2, :]  # [5, 6, 7, 8]
        1         y_row = similar(x_row)
        1         add_one(TensorView(x_row), TensorView(y_row))
        1         @test y_row ≈ Float32[6, 7, 8, 9]
        - 
        -         # Test 6: 2D sub-matrix
        1         big_mat = Float32[1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]  # 4×4
        1         x_sub = @view big_mat[2:3, 2:3]  # 2×2 sub-matrix [[6, 7], [10, 11]]
        1         y_sub = similar(x_sub)
        1         add_one(TensorView(x_sub), TensorView(y_sub))
        1         @test y_sub ≈ Float32[7 8; 11 12]
        - 
        -         # Test 7: 3D array
        1         x_3d = reshape(Float32[1:24...], 2, 3, 4)  # 2×3×4
        1         y_3d = similar(x_3d)
        1         add_one(TensorView(x_3d), TensorView(y_3d))
        1         @test y_3d ≈ x_3d .+ 1
        - 
        -         # Test 8: 3D slice
        1         arr_3d = reshape(Float32[1:60...], 3, 4, 5)  # 3×4×5
        1         x_3d_slice = @view arr_3d[2:3, 2:3, 2:4]  # 2×2×3 sub-tensor
        1         y_3d_slice = similar(x_3d_slice)
        1         add_one(TensorView(x_3d_slice), TensorView(y_3d_slice))
        1         @test y_3d_slice ≈ x_3d_slice .+ 1
        - 
        -         # Test 9: Complex strided view
       49         complex_mat = Float32[i + j for i in 1:6, j in 1:8]  # 6×8
        1         x_complex = @view complex_mat[1:2:end, 1:3:end]  # Every 2nd row, 3rd col
        1         y_complex = similar(x_complex)
        1         add_one(TensorView(x_complex), TensorView(y_complex))
        1         @test y_complex ≈ x_complex .+ 1
        -     end
        - 
        -     @testset "add_one_cuda - GPU Arrays (Optional)" begin
        2         if !CUDA_AVAILABLE
        1             @info "CUDA tests skipped: CUDA not available"
        1             @test_skip "CUDA not available"
        -         else
        -             # Load CUDA fixture
        0             mod = load_fixture("add_one_cuda")
        0             @test mod isa TVMModule
        0             @test implements_function(mod, "add_one_cuda")
        - 
        0             add_one_cuda = mod["add_one_cuda"]
        0             @test add_one_cuda isa TVMFunction
        - 
        -             # Test 1: Basic CUDA array
        0             x_gpu = CUDA.CuArray(Float32[1, 2, 3, 4, 5])
        0             y_gpu = CUDA.similar(x_gpu)
        0             add_one_cuda(TensorView(x_gpu), TensorView(y_gpu))
        0             @test Array(y_gpu) ≈ Float32[2, 3, 4, 5, 6]
        - 
        -             # Test 2: CUDA array with stride (every 2nd element)
        0             x_vec_gpu = CUDA.CuArray(Float32[1, 2, 3, 4, 5, 6, 7, 8])
        0             y_vec_gpu = CUDA.zeros(Float32, 8)
        0             x_strided = @view x_vec_gpu[1:2:end]
        0             y_strided = @view y_vec_gpu[1:2:end]
        0             add_one_cuda(TensorView(x_strided), TensorView(y_strided))
        0             @test Array(y_strided) ≈ Float32[2, 4, 6, 8]
        - 
        -             # Test 3: 2D CUDA array
        0             x_mat_gpu = CUDA.CuArray(Float32[1 2 3; 4 5 6])
        0             y_mat_gpu = CUDA.similar(x_mat_gpu)
        0             add_one_cuda(TensorView(x_mat_gpu), TensorView(y_mat_gpu))
        0             @test Array(y_mat_gpu) ≈ Float32[2 3 4; 5 6 7]
        - 
        -             # Test 4: Column slice (contiguous on GPU)
        0             mat_gpu = CUDA.CuArray(Float32[1 2 3 4; 5 6 7 8; 9 10 11 12])
        0             x_col = @view mat_gpu[:, 2]
        0             y_col = CUDA.similar(x_col)
        0             add_one_cuda(TensorView(x_col), TensorView(y_col))
        1             @test Array(y_col) ≈ Float32[3, 7, 11]
        -         end
        -     end
        - 
        -     @testset "add_one_metal - GPU Arrays (Optional)" begin
        2         if !METAL_AVAILABLE
        1             @info "Metal tests skipped: Metal not available"
        1             @test_skip "Metal not available"
        -         else
        -             # Load Metal fixture
        0             mod = load_fixture("add_one_metal")
        0             @test mod isa TVMModule
        0             @test implements_function(mod, "add_one_metal")
        - 
        0             add_one_metal = mod["add_one_metal"]
        0             @test add_one_metal isa TVMFunction
        - 
        -             # Test 1: Simple 1D vector
        0             x_metal = Metal.MtlArray(Float32[1, 2, 3, 4, 5])
        0             y_metal = Metal.zeros(Float32, 5)
        0             add_one_metal(TensorView(x_metal), TensorView(y_metal))
        0             Metal.synchronize()
        0             @test Array(y_metal) ≈ Float32[2, 3, 4, 5, 6]
        - 
        -             # Test 2: 1D strided view (every 2nd element)
        0             x_vec_metal = Metal.MtlArray(Float32[1, 2, 3, 4, 5, 6, 7, 8])
        0             y_vec_metal = Metal.zeros(Float32, 8)
        0             x_strided = @view x_vec_metal[1:2:end]  # [1, 3, 5, 7]
        0             y_strided = @view y_vec_metal[1:2:end]
        0             add_one_metal(TensorView(x_strided), TensorView(y_strided))
        0             Metal.synchronize()
        0             @test Array(y_strided) ≈ Float32[2, 4, 6, 8]
        - 
        -             # Test 3: 2D Matrix (Column-Major Layout)
        0             x_mat_metal = Metal.MtlArray(Float32[1 2 3; 4 5 6])  # 2×3
        0             y_mat_metal = Metal.similar(x_mat_metal)
        0             add_one_metal(TensorView(x_mat_metal), TensorView(y_mat_metal))
        0             Metal.synchronize()
        0             @test Array(y_mat_metal) ≈ Float32[2 3 4; 5 6 7]
        - 
        -             # Test 4: Column slice (contiguous in column-major)
        0             mat_metal = Metal.MtlArray(Float32[1 2 3 4; 5 6 7 8; 9 10 11 12])
        0             x_col = @view mat_metal[:, 2]  # [2, 6, 10]
        0             y_col = Metal.similar(x_col)
        0             add_one_metal(TensorView(x_col), TensorView(y_col))
        0             Metal.synchronize()
        0             @test Array(y_col) ≈ Float32[3, 7, 11]
        - 
        -             # Test 5: Row slice (NON-contiguous, stride > 1)
        0             x_row = @view mat_metal[2, :]  # [5, 6, 7, 8]
        0             y_row = Metal.similar(x_row)
        0             add_one_metal(TensorView(x_row), TensorView(y_row))
        0             Metal.synchronize()
        0             @test Array(y_row) ≈ Float32[6, 7, 8, 9]
        - 
        -             # Test 6: 2D sub-matrix (complex strides)
        0             big_mat = Metal.MtlArray(Float32[1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16])
        0             x_sub = @view big_mat[2:3, 2:3]  # 2×2 sub-matrix
        0             y_sub = Metal.similar(x_sub)
        0             add_one_metal(TensorView(x_sub), TensorView(y_sub))
        0             Metal.synchronize()
        0             @test Array(y_sub) ≈ Float32[7 8; 11 12]
        - 
        1             @info "✓ Metal tests passed"
        -         end
        -     end
        - end
